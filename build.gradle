import org.w3c.dom.Element
import org.apache.tools.ant.filters.ReplaceTokens

buildscript {
	repositories {
		jcenter()
		mavenCentral()
		maven { url = "http://files.minecraftforge.net/maven" }
	}
	dependencies {
		classpath 'net.minecraftforge.gradle:ForgeGradle:3.+'
	}
}

repositories {
	maven {
		url "https://maven.tehnut.info"
	}
	maven {
		url "https://www.cursemaven.com"
	}
	maven {
		url = "https://maven.blamejared.com"
	}
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'idea'
apply plugin: 'maven'
apply plugin: 'maven-publish'

ext.configFile = file "build.properties"
configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    ext.config = new ConfigSlurper().parse prop
}

def mcVersion = config.mc_version
def forgeVersion = config.forge_version

def modName = config.mod_name
def modVersion = config.mod_version

version = "${mcVersion}-${config.mod_version}"

group = config.package_group
archivesBaseName = config.mod_name

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
	mappings channel: 'snapshot', version: config.mappings_version

	runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
        }

        server {
            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
        }
    }
}

dependencies {
	minecraft "net.minecraftforge:forge:${mcVersion}-${forgeVersion}"

	// Compile against full Hwyla jar.
	compile "mcp.mobius.waila:Hwyla:1.8.26-B41_1.12.2"

	// Compile against Serene Seasons, but don't use at runtime.
	compileOnly "curse.maven:SereneSeasons-291874:2799213"

	// Use Patchouli at runtime only (for testing the guide book, which is exclusively Json).
	runtime "vazkii.patchouli:Patchouli:1.0-19.96"
}

processResources {
	inputs.property "version", project.version
	inputs.property "mcversion", mcVersion

	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'

		expand 'version': project.version, 'mcversion': mcVersion
	}

	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}
}

// Assign version constant in ModConstants.
task prepareSources(type: Copy) {
	from('src/main/java')
	into('build/src/main/java')
	filter(ReplaceTokens, tokens: [VERSION: version.toString()])
}

compileJava {
	source = prepareSources.outputs
}

task sourcesJar(type: Jar) {
	classifier = 'sources'
	from sourceSets.main.allJava
}

task deobfJar(type: Jar) {
	from sourceSets.main.output
	classifier = 'deobf'
}

tasks.build.dependsOn deobfJar

jar {
	manifest {
		attributes([
				"Specification-Title": "Dynamic Trees",
				"Specification-Vendor": "ferreusveritas",
				"Specification-Version": "1", // We are version 1 of ourselves
				"Implementation-Title": project.name,
				"Implementation-Version": project.version,
				"Implementation-Vendor" :"ferreusveritas",
				"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
	}
}

jar.finalizedBy('reobfJar')

tasks.withType(GenerateModuleMetadata) {
	enabled = false
}

publishing {
	publications {
		mavenJava(MavenPublication) {
			setArtifactId("${modName}-${mcVersion}")
			setVersion(modVersion)

			from components.java

			pom {
				url = "https://github.com/ferreusveritas/${modName}".toString()
				licenses {
					license {
						name = 'MIT'
						url = 'https://mit-license.org'
					}
				}
				developers {
					developer {
						id = "ferreusveritas"
						name = "Ferreus Veritas"
					}
					developer {
						id = "supermassimo"
						name = "Max Hyper"
					}
					developer {
						id = "Harleyoc1"
						name = "Harley O'Connor"
						email = "Harleyoc1@gmail.com"
					}
				}
				scm {
					connection = "scm:git:git://github.com/ferreusveritas/${modName}.git".toString()
					developerConnection = "scm:git:ssh://github.com/ferreusveritas/${modName}.git".toString()
					url = "https://github.com/ferreusveritas/${modName}".toString()
				}
			}

			pom.withXml { xmlProvider ->
				final Element element = xmlProvider.asElement();

				// Clear dependencies.
				element.getChildNodes().each { node ->
					if (node.getNodeName() == "dependencies")
						element.removeChild(node)
				}
			}
		}
	}
	repositories {
		maven {
			url "file:///${project.projectDir}/mcmodsrepo"
		}
		if (project.hasProperty("harleyOConnorMavenUsername") && project.hasProperty("harleyOConnorMavenPassword")) {
			maven {
				name = "HarleyOConnorMaven"
				url = uri("https://harleyoconnor.com/maven")
				credentials {
					username = property("harleyOConnorMavenUsername")
					password = property("harleyOConnorMavenPassword")
				}
			}
		} else {
			project.logger.log(LogLevel.WARN, "Credentials for maven not detected; it will be disabled.")
		}
	}
}

idea {
    module {
        inheritOutputDirs = true
    }
    module.downloadJavadoc = true
    module.downloadSources = true
}

artifacts {
    archives jar
    archives sourcesJar
    archives deobfJar
}
